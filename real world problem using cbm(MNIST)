# denoise_mnist_autoencoder.py
import torch
import torch.nn as nn
import torch.optim as optim
from torchvision import datasets, transforms
from torch.utils.data import DataLoader, TensorDataset
import matplotlib.pyplot as plt
import random
import numpy as np

# -----------------------------
# 0. Repro + device
# -----------------------------
seed = 42
random.seed(seed)
np.random.seed(seed)
torch.manual_seed(seed)
torch.cuda.manual_seed_all(seed)
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

# -----------------------------
# 1. Load MNIST dataset
# -----------------------------
transform = transforms.ToTensor()  # gives tensors in [0,1]
train_data = datasets.MNIST(root="./data", train=True, download=True, transform=transform)
test_data = datasets.MNIST(root="./data", train=False, download=True, transform=transform)

# Convert images to [0,1] tensors (already true with ToTensor)
train_images = train_data.data.float() / 255.0  # [N, 28, 28]
test_images = test_data.data.float() / 255.0  # [N, 28, 28]

# -----------------------------
# 2. Add Gaussian noise
# -----------------------------
def add_gaussian_noise(images, mean=0.0, std=0.3):
    noise = torch.randn_like(images) * std + mean
    noisy = torch.clamp(images + noise, 0., 1.)
    return noisy

noisy_train = add_gaussian_noise(train_images, std=0.3)
noisy_test = add_gaussian_noise(test_images, std=0.3)

# Wrap into dataset: shape needs [N, 1, 28, 28]
train_dataset = TensorDataset(noisy_train.unsqueeze(1), train_images.unsqueeze(1))
test_dataset = TensorDataset(noisy_test.unsqueeze(1), test_images.unsqueeze(1))

train_loader = DataLoader(train_dataset, batch_size=128, shuffle=True, num_workers=2, pin_memory=torch.cuda.is_available())
test_loader = DataLoader(test_dataset, batch_size=128, shuffle=False, num_workers=2, pin_memory=torch.cuda.is_available())

# -----------------------------
# 3. Conv Autoencoder
# -----------------------------
class ConvAutoencoder(nn.Module):
    def __init__(self):  # FIXED: was _init_
        super().__init__()  # FIXED: was super()._init_()
        # Encoder: 28x28 -> 14x14 -> 7x7
        self.encoder = nn.Sequential(
            nn.Conv2d(1, 16, 3, stride=2, padding=1),  # 28->14
            nn.ReLU(inplace=True),
            nn.Conv2d(16, 32, 3, stride=2, padding=1),  # 14->7
            nn.ReLU(inplace=True),
        )
        # Decoder: 7x7 -> 14x14 -> 28x28
        self.decoder = nn.Sequential(
            nn.ConvTranspose2d(32, 16, 3, stride=2, padding=1, output_padding=1),  # 7->14
            nn.ReLU(inplace=True),
            nn.ConvTranspose2d(16, 1, 3, stride=2, padding=1, output_padding=1),  # 14->28
            nn.Sigmoid()
        )

    def forward(self, x):
        z = self.encoder(x)
        return self.decoder(z)

# Instantiate model
model = ConvAutoencoder().to(device)
criterion = nn.MSELoss()
optimizer = optim.Adam(model.parameters(), lr=1e-3)

# -----------------------------
# 4. Train
# -----------------------------
num_epochs = 5
for epoch in range(1, num_epochs + 1):
    model.train()
    running = 0.0
    for noisy_imgs, clean_imgs in train_loader:
        noisy_imgs = noisy_imgs.to(device, non_blocking=True)
        clean_imgs = clean_imgs.to(device, non_blocking=True)

        optimizer.zero_grad(set_to_none=True)
        output = model(noisy_imgs)
        loss = criterion(output, clean_imgs)
        loss.backward()
        optimizer.step()
        running += loss.item()

    avg_loss = running / len(train_loader)

    # Validation
    model.eval()
    with torch.no_grad():
        val_running = 0.0
        for noisy_imgs, clean_imgs in test_loader:
            noisy_imgs = noisy_imgs.to(device, non_blocking=True)
            clean_imgs = clean_imgs.to(device, non_blocking=True)
            out = model(noisy_imgs)
            val_running += criterion(out, clean_imgs).item()
    val_loss = val_running / len(test_loader)
    print(f"Epoch [{epoch}/{num_epochs}]  train MSE: {avg_loss:.4f}  val MSE: {val_loss:.4f}")

# -----------------------------
# 5. Visualize
# -----------------------------
model.eval()
with torch.no_grad():
    noisy_imgs, clean_imgs = next(iter(test_loader))
    noisy_imgs = noisy_imgs.to(device)
    reconstructed = model(noisy_imgs).cpu()
    clean_imgs = clean_imgs.cpu()
    noisy_imgs = noisy_imgs.cpu()

# Plot examples
fig, axes = plt.subplots(3, 6, figsize=(10, 5))
for i in range(6):
    axes[0, i].imshow(clean_imgs[i].squeeze(), cmap="gray")
    axes[0, i].set_title("Clean");  axes[0, i].axis("off")
    axes[1, i].imshow(noisy_imgs[i].squeeze(), cmap="gray")
    axes[1, i].set_title("Noisy");  axes[1, i].axis("off")
    axes[2, i].imshow(reconstructed[i].squeeze(), cmap="gray")
    axes[2, i].set_title("Denoised"); axes[2, i].axis("off")

plt.tight_layout()
plt.show()

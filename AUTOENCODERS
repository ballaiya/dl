# UNDERCOMPLETE AUTOENCODER 
import numpy as np 
import tensorflow as tf 
from tensorflow.keras.layers import Input, Dense 
from tensorflow.keras.models import Model 

# Generate random data (1000 samples, 5 features) 
data = np.random.rand(1000, 5) 

# ----------- Build Undercomplete Autoencoder ----------- 
input_data = Input(shape=(5,)) 
encoded = Dense(2, activation='relu', name='encoder')(input_data)   # bottleneck (lower dimension) 
decoded = Dense(5, activation='sigmoid', name='decoder')(encoded)   # reconstruct original data 
autoencoder = Model(input_data, decoded) 

# Compile and Train 
autoencoder.compile(optimizer='adam', loss='mse') 
autoencoder.fit(data, data, epochs=50, batch_size=32, shuffle=True) 

# Encoder Model (Compression) 
encoder = Model(input_data, encoded) 
compressed_data = encoder.predict(data) 

# Decoder Model (Decompression) 
encoded_input = Input(shape=(2,)) 
decoder_layer = autoencoder.get_layer('decoder')(encoded_input) 
decoder = Model(encoded_input, decoder_layer) 
reconstructed_data = decoder.predict(compressed_data) 

print("Original Data Shape:", data.shape) 
print("Compressed Data Shape:", compressed_data.shape) 
print("Reconstructed Data Shape:", reconstructed_data.shape) 


# CONTRACTIVE AUTOENCODER 
import tensorflow.keras.backend as K 

# Generate random data (1000 samples, 5 features) 
data = np.random.rand(1000, 5) 

# ----------- Build Contractive Autoencoder ----------- 
input_data = Input(shape=(5,)) 
encoded = Dense(2, activation='relu', name='encoded')(input_data) 
decoded = Dense(5, activation='sigmoid', name='decoded')(encoded) 
autoencoder = Model(input_data, decoded) 

# Contractive Loss 
def contractive_loss(y_true, y_pred): 
    mse_loss = tf.reduce_mean(tf.square(y_true - y_pred))  # normal reconstruction loss 
    W = autoencoder.get_layer('encoded').kernel            # encoder weights 
    contractive = tf.reduce_sum(tf.square(W))              # penalty term 
    return mse_loss + 1e-4 * contractive                   # combine both 

autoencoder.compile(optimizer='adam', loss=contractive_loss) 
autoencoder.fit(data, data, epochs=50, batch_size=32, shuffle=True) 

# Encoder Model (Compression) 
encoder = Model(input_data, encoded) 
compressed_data = encoder.predict(data) 

# Decoder Model (Reconstruction) 
encoded_input = Input(shape=(2,)) 
decoder_layer = autoencoder.get_layer('decoded')(encoded_input) 
decoder = Model(encoded_input, decoder_layer) 
reconstructed_data = decoder.predict(compressed_data) 

print("Original Data Shape:", data.shape) 
print("Compressed Data Shape:", compressed_data.shape) 
print("Reconstructed Data Shape:", reconstructed_data.shape)
